<h1 id="vad-är-egentligen-fourierserier-och-fouriertransformer">Vad är egentligen Fourierserier och Fouriertransformer?</h1>
<p>En vanlig teknik för en ingenjör är att ta en svår problem och dela in den flera enklare delar. Till exempel så går det att dela in en komplicerad <strong>periodisk</strong> signal till flera begripliga sinusvågar vilket är lättare att förstå och räkna på. Summan av sinusvågarna kallas för en Fourierserie. Vad händer då om signalen inte är periodisk?</p>
<p>En Fouriertransform är en transform som kan användas för att föra över en funktion från tidsplanet till frekvensplanet. Även denna egenskap kan göra signalen lättare att hantera!</p>
<p>När är då Fourierserier och Fouriertransformer användbart? Jo, de brukar användas inom TV och radio. Med andra ord, olika system vilket även innefattar LTI-system!</p>
<h1 id="fourierserier">Fourierserier</h1>
<p>Då ska vi börja med fourierserier!</p>
<p>För att vi ska introducera fourierserier, så får du föreställa dig en trivial signal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>ω</mi><mn>0</mn></msub><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">sin(\omega_0 t)</annotation></semantics></math>. Om vi skriver om sinus med hjälp av Eulers fórmel får vi följande utseende:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>ω</mi><mn>0</mn></msub><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mrow><msup><mi>e</mi><mrow><mi>j</mi><msub><mi>ω</mi><mn>0</mn></msub><mi>t</mi></mrow></msup><mo>−</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>j</mi><msub><mi>ω</mi><mn>0</mn></msub><mi>t</mi></mrow></msup></mrow><mrow><mn>2</mn><mi>i</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">sin(\omega_0 t) = \frac{e^{j \omega_0 t}  - e^{-j \omega_0 t}}{2i}</annotation></semantics></math> Detta är egentligen en form av en Fourier serie. För att förklara detta i mer detalj så tar vi upp ett exempel. Föreställ dig nu den bästa smoothien du någonsin har druckit och så fort den är slut då måste du ha en till! Men så känner du att du skulle vilja ha samma smoothie som du dricker fast med choklad i istället för jordgubb. Då kan du antingen fråga om en ny smoothie från han som sitter i kassan, eller så bryter du ner smoothien i dess ingredienser, tar bort all jordgubb och tillsätter choklad istället. Det andra alternativet låter väl ändå roligare? Då representerar vi smoothien med ett system med insignalen: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mrow><mo>−</mo><mi>t</mi></mrow><mi>π</mi></mfrac><mo>+</mo><mn>2</mn><mo>,</mo><mspace width="1.0em"></mspace><mi>t</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>2</mn><mi>π</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">f(t) = \frac{-t}{\pi} + 2, \quad t \in [0,2 \pi]</annotation></semantics></math> vars graf man kan se här</p>
<div class="figure">
<embed src="smoothie.eps" />
<p class="caption">Graf på hur mycket smoothie du har kvar!<span data-label=""></span></p>
</div>
<p>Grafen visar hur mycket som finns kvar medan du dricker och är periodisk eftersom du bara <strong>måste</strong> ha en till. Systemsvaret ska bara påverka frekvensen med jordgubb i. Därför utvecklar vi smoothien till en serie som innehåller alla dess frekvenser(ingredienser). Vi kan då hitta frekvensen som vi vill påverka och så vet vi också vilka vi vill låta bli att påverka. För att kunna göra den här uppdelningen så krävs följande formel: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mo>−</mo><mn>1</mn></mrow><mn>1</mn></munderover><msub><mi>C</mi><mi>k</mi></msub><msup><mi>e</mi><mrow><mi>k</mi><mi>j</mi><mi>t</mi></mrow></msup></mrow><annotation encoding="application/x-tex">f(t) = \sum_{k=-1}^1 C_k e^{k j t}</annotation></semantics></math> där konstanten <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mi>k</mi></msub><annotation encoding="application/x-tex">C_k</annotation></semantics></math> är given från: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>k</mi></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mo>−</mo><mi>∞</mi></mrow><mi>∞</mi></munderover><msub><mi>C</mi><mi>k</mi></msub><msup><mi>e</mi><mrow><mi>k</mi><mi>j</mi><mi>t</mi></mrow></msup></mrow><annotation encoding="application/x-tex">C_k = \sum_{k=-\infty}^{\infty} C_k e^{k j t}</annotation></semantics></math> För vår smoothie så kommer serien ha följande utseende: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>2</mn><munderover><mo>∑</mo><mn>1</mn><mi>∞</mi></munderover><mfrac><mrow><mo stretchy="false" form="prefix">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">)</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mi>n</mi></mfrac><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(t) = 2 \sum_{1}^{\infty} \frac{(-1)^{n+1}}{n} sin(n t)</annotation></semantics></math> Obs! <em>Om vi istället valt att gå till kassan och bett om en ny smoothie, så hade vi alltså bytt insignal in i vårt system istället för att påverka den vi har.</em> En mer matematiskt korrekt förklaring är att återigen observera den enkla signalen <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>ω</mi><mn>0</mn></msub><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">sin(\omega_0 t)</annotation></semantics></math>. Som tidigare nämnt kan den skrivas om enligt Eulers formel till <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><msup><mi>e</mi><mrow><mi>j</mi><msub><mi>ω</mi><mn>0</mn></msub><mi>t</mi></mrow></msup><mo>−</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>j</mi><msub><mi>ω</mi><mn>0</mn></msub><mi>t</mi></mrow></msup></mrow><mrow><mn>2</mn><mi>j</mi></mrow></mfrac><annotation encoding="application/x-tex">\frac{e^{j \omega_0 t} - e^{-j \omega_0 t}}{2j}</annotation></semantics></math> vilket kan skrivas som om vi låter <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">C_0=0</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>j</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">C_{1}=\frac{1}{2j}</annotation></semantics></math> och <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub><mo>=</mo><mo>−</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>j</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">C_{1}=-\frac{1}{2j}</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mo>−</mo><mn>1</mn></mrow><mn>1</mn></munderover><msub><mi>C</mi><mi>k</mi></msub><msup><mi>e</mi><mrow><mi>j</mi><mi>k</mi><msub><mi>ω</mi><mn>0</mn></msub><mi>t</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\sum_{k=-1}^1 C_k e^{j k \omega_0 t}</annotation></semantics></math> Låter vi nu även <strong>alla</strong> andra <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>k</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">C_k = 0</annotation></semantics></math> förutom <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mn>1</mn></msub><annotation encoding="application/x-tex">C_1</annotation></semantics></math> och <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mrow><mo>−</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">C_{-1}</annotation></semantics></math> blir formen <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mo>−</mo><mi>∞</mi></mrow><mi>∞</mi></munderover><msub><mi>C</mi><mi>k</mi></msub><msup><mi>e</mi><mrow><mi>j</mi><mi>k</mi><msub><mi>ω</mi><mn>0</mn></msub><mi>t</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\sum_{k=-\infty}^{\infty} C_k e^{j k \omega_0 t}</annotation></semantics></math> Det magiska är då att vi bara har skrivit om den ursprungliga funktionen, vilket innebär att <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>ω</mi><mn>0</mn></msub><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mo>−</mo><mi>∞</mi></mrow><mi>∞</mi></munderover><msub><mi>C</mi><mi>k</mi></msub><msup><mi>e</mi><mrow><mi>k</mi><mi>j</mi><mi>t</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\sin(\omega_0 t) = \sum_{k=-\infty}^{\infty} C_k e^{k j t}</annotation></semantics></math> Detta blir då en form av det som kallas för Fourierserier. Man skriver om allt så att det uttrycks som komponenter till den hela signalen som man ”slår” isär. Om man har en enkel signal som i vårt fall så är det kanske inte riktigt så givande, men om man har en större, mer komplicerad signal så skulle den vara svår att studera i sitt grundutförande och det skulle bli mycket lättare att bara bryta upp den till sina komponenter istället då.</p>
<p>En Fourierserie visar en amplitud mot dess frekvens, så man vet ”hur mycket” bidrag man får från varje frekvens. Så ett ordentligt exempel skulle vara att man har ett filter som filtrerar bort alla frekvenser högre än en viss frekvens <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>. Då kan man ta reda på vilka frekvenser som kommer att påverkas efter att filtret applicerats genom att bryta upp signalen till dess komponenter.</p>
<p>Detta är då användningsområdet för Fourierserier i ett nötskal, inom signaler och system i alla fall. Det vill säga, bryta upp en signal i dess frekvenser för att finna mer information och tydligt kunna beräkna hur systemsvaret påverkar insignalen. Hur skulle det funka om insignalen inte var periodisk?</p>
<p>Det är där Fouriertransformen kommer in!</p>
<h1 id="fouriertransform">Fouriertransform</h1>
<p>Observera att signaler inte nödvändigtvis behöver vara periodiska. Hur ska man då kunna behandla dessa om en fourierserieutveckling kräver periodicitet? Vi transformerar dem! Om ni kommer ihåg att <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>e</mi><mrow><mi>j</mi><mi>ω</mi><mi>x</mi></mrow></msup><annotation encoding="application/x-tex">e^{j\omega x}</annotation></semantics></math> är en trigonometrisk funktion enligt Eulers formel. Då kanske följande formler blir logiska, och om de inte blir det så är det enda ni behöver veta att formlerna ”transformerar” signalen så att den kan studeras i en frekvensdomän.</p>
<p>Definition för fouriertransform: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>f</mi><mo accent="true">^</mo></mover><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msubsup><mo>∫</mo><mrow><mo>−</mo><mi>∞</mi></mrow><mi>∞</mi></msubsup><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>j</mi><mi>ω</mi><mi>t</mi></mrow></msup><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\hat{f}(\omega) = \int_{-\infty}^{\infty} f(t) e^{-j \omega t} dt</annotation></semantics></math></p>
<p>Vi kan sedan observera att det är samma sak som att beräkna ut konstanten <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mi>k</mi></msub><annotation encoding="application/x-tex">C_k</annotation></semantics></math> men i detta fall så är <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ω</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\omega_0</annotation></semantics></math> en variabel istället för en konstant, vilken betecknas som <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ω</mi><annotation encoding="application/x-tex">\omega</annotation></semantics></math> för att visa skillnaden. Detta kan användas inom matematiken för att beräkna differentialekvationer över begränsade tidsintervall. I princip så ändras det hela från ett tidsplan till ett frekvensplan, det vill säga att det ändras från linjer till cirklar. Bli nu inte skrämda av alla dessa integraler. Oftast så tillåts det en tabell som en kan utnyttja för att förenkla hela processen. Vi definerar en operator som fouriertransformerar <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="script"><mi>ℱ</mi></mstyle><annotation encoding="application/x-tex">\mathcal{F}</annotation></semantics></math>. Några viktiga transformer:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ℱ</mi></mstyle><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>a</mi><mi>t</mi></mrow></msup><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mo>−</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{F}(e^{j a t} f(t)) = F(\omega - a)</annotation></semantics></math><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ℱ</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mo stretchy="false" form="prefix">|</mo><mi>a</mi><mo stretchy="false" form="prefix">|</mo></mrow></mfrac><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mfrac><mi>ω</mi><mi>a</mi></mfrac><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{F}(f(at)) = \frac{1}{|a|}F(\frac{\omega}{a})</annotation></semantics></math><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ℱ</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mfrac><mi>d</mi><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>i</mi><mi>ω</mi><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{F}(\frac{d}{dt} f(t)) = i\omega F(\omega)</annotation></semantics></math> Fouriertransformen är även linjär vilket innebär <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ℱ</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mi>f</mi><mo>+</mo><mi>b</mi><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>a</mi><mi>F</mi><mo>+</mo><mi>b</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">\mathcal{F}(a f + b g) = a F + b G</annotation></semantics></math></p>
<p>Om vi då återgår till vårt smoothie-exempel så skulle det vara som att vi låter en maskin hitta alla ingredienser i smoothien åt oss.</p>
<p>Varför skulle det här vara hjälpsamt? Om ni kommer ihåg från innan hur utsignalen till ett systemsvar är givet från <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>*</mo><mi>h</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">y(t) = x(t) * h(t)</annotation></semantics></math>, vilket är en faltning mellan två funktioner. I en frekvensdomän blir motsvarande <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>X</mi><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mo stretchy="false" form="postfix">)</mo><mi>H</mi><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Y(\omega) = X(\omega) H(\omega)</annotation></semantics></math>. Det vill säga en enkel multiplikation mellan insignalen och systemsvaret. <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ℱ</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo>*</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>F</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">\mathcal{F}(f*g) = F G</annotation></semantics></math></p>
<p><strong>Exempel</strong> Ett kontinuerligt LTI-system har insignalen <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>δ</mi><mi>t</mi><mo>+</mo><mo>cos</mo><mo stretchy="false" form="prefix">(</mo><mn>5</mn><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x(t)=\delta{t} + \cos(5 t)</annotation></semantics></math> och impulssvaret <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>2</mn><mi>t</mi></mrow></msup><mi>u</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">h(t) = e^{-2 t} u(t)</annotation></semantics></math>. Hur ser utsignalen ut? <strong>Lösning:</strong></p>
<p>Först beräknas fouriertransformen av impulssvaret ut. <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ℱ</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>H</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mo>+</mo><mi>j</mi><mi>ω</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\mathcal{F}(h) = H = \frac{1}{2+j \omega}</annotation></semantics></math> Eftersom fouriertransformen är linjär så kan vi behandla termerna i insignalen var för sig. Det vill säga <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>ℱ</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mstyle mathvariant="script"><mi>ℱ</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>δ</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mstyle mathvariant="script"><mi>ℱ</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mo>cos</mo><mo stretchy="false" form="prefix">(</mo><mn>5</mn><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>X</mi><mn>1</mn></msub><mo>+</mo><msub><mi>X</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathcal{F} (x) = \mathcal{F}(\delta{t}) + \mathcal{F}(\cos(5 t) = X_1 + X_2</annotation></semantics></math> Som båda är givna från tabeller och blir <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>δ</mi><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mo>−</mo><mn>5</mn><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mi>δ</mi><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mo>+</mo><mn>5</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">1+\pi(\delta(\omega - 5) + \delta(\omega + 5))</annotation></semantics></math>. Vi har nu tagit bort faltningen och har följande förhållande. <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>=</mo><mi>X</mi><mi>H</mi><mo>=</mo><msub><mi>X</mi><mn>1</mn></msub><mi>H</mi><mo>+</mo><msub><mi>X</mi><mn>2</mn></msub><mi>H</mi></mrow><annotation encoding="application/x-tex">Y = X H = X_1 H + X_2 H</annotation></semantics></math> Vilket innebär att vi har löst problemet om vi återtransformerar vänsterledet. Vi börjar med <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mi>H</mi></mrow><annotation encoding="application/x-tex">X_1 H</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo>=</mo><msup><mstyle mathvariant="script"><mi>ℱ</mi></mstyle><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false" form="prefix">(</mo><msub><mi>X</mi><mn>1</mn></msub><mi>H</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msubsup><mo>∫</mo><mrow><mo>−</mo><mi>∞</mi></mrow><mi>∞</mi></msubsup><mn>1</mn><mo>⋅</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mo>+</mo><mi>j</mi><mi>ω</mi></mrow></mfrac><msup><mi>e</mi><mrow><mi>j</mi><mi>ω</mi><mi>t</mi></mrow></msup><mi>d</mi><mi>ω</mi><mo>=</mo><msup><mi>e</mi><mrow><mn>2</mn><mi>t</mi></mrow></msup><mi>u</mi><mo stretchy="false" form="prefix">(</mo><mo>−</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">y_1=\mathcal{F}^{-1}(X_1 H) =  \int_{-\infty}^{\infty} 1 \cdot \frac{1}{2+j \omega} e^{j \omega t} d\omega = e^{2 t} u(-t)</annotation></semantics></math> Nu återstår bara <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>2</mn></msub><mi>H</mi></mrow><annotation encoding="application/x-tex">X_2 H</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mn>2</mn></msub><mo>=</mo><msup><mstyle mathvariant="script"><mi>ℱ</mi></mstyle><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false" form="prefix">(</mo><msub><mi>X</mi><mn>2</mn></msub><mi>H</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msubsup><mo>∫</mo><mrow><mo>−</mo><mi>∞</mi></mrow><mi>∞</mi></msubsup><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>δ</mi><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mo>−</mo><mn>5</mn><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mi>δ</mi><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mo>+</mo><mn>5</mn><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>⋅</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mo>+</mo><mi>j</mi><mi>ω</mi></mrow></mfrac><msup><mi>e</mi><mrow><mi>j</mi><mi>ω</mi><mi>t</mi></mrow></msup><mi>d</mi><mi>ω</mi></mrow><annotation encoding="application/x-tex">y_2=\mathcal{F}^{-1}(X_2 H) = \int_{-\infty}^{\infty} \pi(\delta(\omega - 5) + \delta(\omega + 5)) \cdot \frac{1}{2+j \omega} e^{j \omega t} d\omega</annotation></semantics></math> Integralen ovan innehåller impulsfunktioner vilket gör den svår att förstå intuitiv. Om en kollar på impulsfunktionens definition så ser vi att integranden bara kan anta värden då <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">\omega=5</annotation></semantics></math> eller <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ω</mi><mo>=</mo><mo>−</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">\omega =-5</annotation></semantics></math> eftersom annars tar impulsfunktionen värdet 0. Detta innebär att integralen blir följande <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mn>2</mn><mo>+</mo><mi>j</mi><mn>5</mn></mrow></mfrac><msup><mi>e</mi><mrow><mi>j</mi><mn>5</mn><mi>t</mi></mrow></msup><mo>+</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mo>−</mo><mi>j</mi><mn>5</mn></mrow></mfrac><msup><mi>e</mi><mrow><mo>−</mo><mi>j</mi><mn>5</mn><mi>t</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\frac{1}{2+j 5} e^{j 5 t} + \frac{1}{2-j 5} e^{-j 5 t}</annotation></semantics></math> Utsignalen blir då <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>y</mi><mn>1</mn></msub><mo>+</mo><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">y=y_1 + y_2</annotation></semantics></math> eller <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>e</mi><mrow><mn>2</mn><mi>t</mi></mrow></msup><mi>u</mi><mo stretchy="false" form="prefix">(</mo><mo>−</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mo>+</mo><mi>j</mi><mn>5</mn></mrow></mfrac><msup><mi>e</mi><mrow><mi>j</mi><mn>5</mn><mi>t</mi></mrow></msup><mo>+</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mo>−</mo><mi>j</mi><mn>5</mn></mrow></mfrac><msup><mi>e</mi><mrow><mo>−</mo><mi>j</mi><mn>5</mn><mi>t</mi></mrow></msup></mrow><annotation encoding="application/x-tex">e^{2 t} u(-t) + \frac{1}{2+j 5} e^{j 5 t} + \frac{1}{2-j 5} e^{-j 5 t}</annotation></semantics></math> Sen finns även Plancherel’s ekvation: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mrow><mo>−</mo><mi>∞</mi></mrow><mi>∞</mi></msubsup><mo stretchy="false" form="prefix">|</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="prefix">|</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>π</mi></mrow></mfrac><msubsup><mo>∫</mo><mrow><mo>−</mo><mi>∞</mi></mrow><mi>∞</mi></msubsup><mo stretchy="false" form="prefix">|</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="prefix">|</mo><mn>2</mn></msup><mi>d</mi><mi>ω</mi></mrow><annotation encoding="application/x-tex">\int_{-\infty}^{\infty} |f(x)|^2 dx = \frac{1}{2 \pi}\int_{-\infty}^{\infty} |F(\omega)|^2 d\omega</annotation></semantics></math> Det vill säga normen(alternativt ord?) av en funktion är samma sak som normen av dess fouriertransform delat med <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>π</mi></mrow><annotation encoding="application/x-tex">2 \pi</annotation></semantics></math>. Eller mer specifikt, delat med perioden som den är definierad över. Inom detta området innebär normen av en signal den totala energin av signalen. <strong>Exempel</strong> Vi vill veta den totala energin i insignalen till ett system givet utsignalen y och impulssvaret h. Fouriertransformerar vi systemet får vi <span class="math display">$$XH = Y \implies X = Y/H$$</span> Detta ger oss enligt Plancherels formel följande relation <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><mn>2</mn><mi>π</mi></mrow></mfrac><msubsup><mo>∫</mo><mrow><mo>−</mo><mi>∞</mi></mrow><mi>∞</mi></msubsup><mo stretchy="false" form="prefix">|</mo><mi>X</mi><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="prefix">|</mo><mn>2</mn></msup><mi>d</mi><mi>ω</mi><mo>=</mo><msubsup><mo>∫</mo><mrow><mo>−</mo><mi>∞</mi></mrow><mi>∞</mi></msubsup><mo stretchy="false" form="prefix">|</mo><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="prefix">|</mo><mn>2</mn></msup><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\frac{1}{2 \pi} \int_{-\infty}^{\infty} |X(\omega)|^2 d \omega = \int_{-\infty}^{\infty} |x(t)|^2 d t</annotation></semantics></math> Där vi kan se att högerledet är den totala energin från insignalen. Det vill säga, bara lös vänsterledet.</p>
<p>Så varför använda fouriertransform? Det kan vara svårt att bryta upp en faltning! (Det vill säga vi vill bryta upp <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>*</mo><mi>h</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x*h=y</annotation></semantics></math> så att x blir ensam.) Så varför använda Plancherels sats? Mycket lättare att slippa återtransformera och sedan beräkna normen. (Det vill säga högerledet...) <strong>OBS!</strong> Tillskillnad från när en utvecklar signalen till dess Fourierserie så är en transformerad funktion <strong>inte</strong> samma sak som den ursprungliga funktionen. Därför önskas det att återtransformera funktionen, vilket görs med följande formel!</p>
<p>Invers fouriertransform - <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>π</mi></mrow></mfrac><msubsup><mo>∫</mo><mrow><mo>−</mo><mi>∞</mi></mrow><mi>∞</mi></msubsup><msup><mi>e</mi><mrow><mi>j</mi><mi>ω</mi><mi>t</mi></mrow></msup><mi>d</mi><mi>ω</mi></mrow><annotation encoding="application/x-tex">f(t) = \frac{1}{2 \pi} \int_{-\infty}^{\infty}  e^{j \omega t} d\omega</annotation></semantics></math></p>
<p>Allt detta är under antagandet att signalens funktion är känd. Vad händer då om bara signalens värden är kända?</p>
<h1 id="diskret-fourier-transform">Diskret Fourier Transform</h1>
<p>Med hjälp av sampling kan vi reducera en kontinuerlig signal till en diskret signal. Därefter kan vi använda definitionen för DFT, <em>diskret fouriertransform</em>, för att omvandla signalen från en tidsdomän till en frekvensdomän. <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo stretchy="false" form="prefix">[</mo><mi>k</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></munderover><mi>x</mi><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>2</mn><mi>π</mi><mi>j</mi><mi>n</mi><mi>k</mi><mi>/</mi><mi>N</mi></mrow></msup></mrow><annotation encoding="application/x-tex">X[k] = \frac{1}{N} \sum_{n=0}^{N-1} x[n] e^{-2 \pi j n k/N}</annotation></semantics></math> Det vill säga, om man vill studera diskreta värden från en signal i dess frekvensdomän, då applicerar man DFT! Och precis som i det kontinuerliga fallet så finns det en invers DFT för att återomvandla signalen. <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></munderover><mi>X</mi><mo stretchy="false" form="prefix">[</mo><mi>k</mi><mo stretchy="false" form="postfix">]</mo><msup><mi>e</mi><mrow><mn>2</mn><mi>π</mi><mi>j</mi><mi>n</mi><mi>k</mi><mi>/</mi><mi>N</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x[n] = \sum_{k=0}^{N-1} X[k] e^{2 \pi j n k/N}</annotation></semantics></math> Rent praktiskt används diskret fouriertransform oftast med sampling från en typ av signal. Detta görs ifall det finns någon typ av okänd signal, där vi känner till <strong>värden</strong> men inte själva <strong>formeln</strong>. Här är även det motsvarande Parsevals ekvation</p>
<p>Parsevals ekvation för diskreta Fouriertransformer <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mi>N</mi></munderover><mo stretchy="false" form="prefix">|</mo><mi>x</mi><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo><msup><mo stretchy="false" form="prefix">|</mo><mn>2</mn></msup><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mo stretchy="false" form="prefix">|</mo><mi>X</mi><mo stretchy="false" form="prefix">[</mo><mi>k</mi><mo stretchy="false" form="postfix">]</mo><msup><mo stretchy="false" form="prefix">|</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\sum_{n=0}^{N} |x[n]|^2 = \frac{1}{N} sum_{k=0}^{N-1} |X[k]|^2</annotation></semantics></math></p>
