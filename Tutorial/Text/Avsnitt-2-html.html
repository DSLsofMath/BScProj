<h1 id="vad-menas-med-lti-system">Vad menas med LTI-system?</h1>
<p><span class="math display">$$x(t) \rightarrow \framebox[1.2\width]{\textbf{LTI-system}} \rightarrow y(t)$$</span></p>
<p>Linjära tidsinvarianta system, eller LTI-system, är logiskt nog system som är linjära och tidsinvarianta. Hurra för logik! Men för att den förklaringen ska bli lite mer begriplig kan det ju vara bra att reda ut vad som menas med “Linjär” och “Tidsinvariant”. Med ett linjärt system menar man, lite förenklat uttryckt, ett system där man kan separera signalerna i sina beståndsdelar. Ett tidsinvariant system är ett system vars egenskaper inte ändras med tiden. En mer detaljerad beskrivning av dessa egenskaper kommer senare men inledelsevis kan vi konstatera att ett LTI-system är ett system med fina konsekventa ekvationer som är relativt enkla att räkna på. Så rysligt praktiskt!</p>
<p>LTI-system är något man använder sig av väldigt mycket inom signallära. Även system som egentligen inte är linjära och tidsinvarianta approximeras ofta till LTI-system, eftersom det är så mycket trevligare att räkna på LTI-system. Alla älskar LTI-system! Åtminstone jämfört med andra system som ändrar sig hela tiden och är odrägliga att försöka räkna på, usch och fy!</p>
<h1 id="egenskaper-hos-lti-system">Egenskaper hos LTI-system</h1>
<p>LTI-system har många trevliga egenskaper som gör att deras vänner gillar dem och deras fiender avundas dem. Nu ska vi ta en kik på ett par av de viktigaste egenskaperna.</p>
<h2 id="linjäritet">Linjäritet</h2>
<p>För att ett system ska vara linjärt måste det uppfylla superpositionsprincipen, vilket innebär att det är både additativt och homogent för er som tycker om att svänga er med fina ord.</p>
<p>I ett system som är additativt kan man dela upp insignalen i mindre komponenter och kika på dessa komponenters utsignaler och dessa kan sedan kombineras till hela insignalens utsignal. Mycket praktiskt! <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">F(x_{1}+x_{2}) = F(x_{1}) + F(x_{2})</annotation></semantics></math> <span class="math display">$$x_{1}(t) + x_{2}(t) \rightarrow \framebox[1.2\width]{\textbf{Additativt system}} \rightarrow \mathrm{y_{1}(t) + y_{2}(t)}$$</span></p>
<p>I ett homogent system kan man bryta ut skalningsfaktorer ifrån insignalen och skala om utsignalen med dessa istället. <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mspace width="0.278em"></mspace><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>a</mi><mspace width="0.278em"></mspace><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mspace width="1.0em"></mspace><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> a är en konstant</mtext></mrow></mrow><annotation encoding="application/x-tex">F(a \; x) = a\;F(x), \quad \mbox{ a är en konstant}</annotation></semantics></math> <span class="math display">$$a x(t) \rightarrow \framebox[1.2\width]{\textbf{Homogent system}} \rightarrow \mathrm{a y(t)}$$</span></p>
<p>Det är dessa två egenskaper som tillsammans utgör superpositionsprincipen. Superpositionsprincipen gör att man kan se insignalerna, och dess komponenter, till ett linjärt system som så grundläggande signaler som möjligt och sen bara skalar och kombinerar utsignalerna de genererar. Kan man visa att ett system uppfyller superpositionsprincipen har man visat att det är linjärt. Hur vet man då om systemet uppfyller superpositionsprincipen? Jo, säg att vi har två signaler <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>1</mn></msub><annotation encoding="application/x-tex">x_1</annotation></semantics></math> och <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>2</mn></msub><annotation encoding="application/x-tex">x_2</annotation></semantics></math>.</p>
<p>Om systemet uppfyller superpositionsprincipen gäller då att:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><mi>b</mi><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>a</mi><mi>F</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mi>b</mi><mi>F</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mspace width="1.0em"></mspace><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> a och b är konstanter</mtext></mrow></mrow><annotation encoding="application/x-tex">F(a x_{1}+b x_{2}) = a F(x_{1}) + b F(x_{2}), \quad
\mbox{ a och b är konstanter}</annotation></semantics></math> <span class="math display">$$a x_{1}(t)+b x_{2}(t) \rightarrow \framebox[1.2\width]{\textbf{SuperPos. system}} \rightarrow \mathrm{a y_{1}(t)+b y_{2}(t)}$$</span></p>
<p>Och därmed är systemet linjärt!</p>
<p><strong>Övning 1:</strong> Här följer ett kodskelett till en funktion som undersöker om ett system är Linjärt. Fyll i det som saknas.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isLinearDisc ::</span> <span class="dt">DiscTimeFun</span> <span class="co">-- ^ Insignal 1</span>
            <span class="ot">-&gt;</span> <span class="dt">DiscTimeFun</span> <span class="co">-- ^ Insignal 2</span>
            <span class="ot">-&gt;</span> <span class="dt">DiscSystem</span>  <span class="co">-- ^ System</span>
            <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="co">-- ^ Skalningsfaktor 1</span>
            <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="co">-- ^ Skalningsfaktor 2</span>
            <span class="ot">-&gt;</span> <span class="dt">DiscTime</span> <span class="co">-- ^ Tid då vi mäter</span>
            <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isLinearDisc x0 x1 sys a b t <span class="fu">=</span> undefined</code></pre></div>
<p><strong>Tips!</strong> Du kommer behöva skala om signalerna, kolla i <span>Signals.hs</span> efter en lämplig funktion.</p>
<h2 id="tidsinvarians">Tidsinvarians</h2>
<p>Med hur är det då med tidsinvarians? Vad är det för egenskaper som gäller där? Jo, ett system är tidsinvariant om en tidsförskjutning i insignalen ger samma tidsförskjutning i utsignalen. Alltså:</p>
<p><span class="math display">$$x(t-c) \rightarrow \framebox[1.2\width]{\textbf{Tidsinvariant system}} \rightarrow y(t-c)$$</span> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="normal">där c är en reel konstant</mtext><annotation encoding="application/x-tex">\mbox{där c är en reel konstant}</annotation></semantics></math></p>
<p><strong>Övning 2:</strong> Implementera en funktion som undersöker om ett system är tidsinvariant i kontinuerlig tid enligt följande:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isTimeInvCont ::</span> <span class="dt">ContTimeFun</span> <span class="ot">-&gt;</span> <span class="dt">ContSystem</span> <span class="ot">-&gt;</span>
                        <span class="dt">ContTime</span> <span class="ot">-&gt;</span> <span class="dt">ContTime</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></code></pre></div>
<p><strong>Tips!</strong> Använd dig av följande funktion för tidsskift:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">timeShift ::</span> <span class="dt">Num</span> time <span class="ot">=&gt;</span> <span class="dt">Signal</span> time val
          <span class="ot">-&gt;</span> time <span class="ot">-&gt;</span> time <span class="ot">-&gt;</span> <span class="dt">Signal</span> time val
timeShift sig o t <span class="fu">=</span> sig (t <span class="fu">-</span> o)</code></pre></div>
<p><strong>Övning 3:</strong> Implementera en funktion som undersöker om ett system är ett LTI-system. Använd dig av funktionerna från övning 1 och 2.</p>
<p><strong>Test:</strong></p>
<p>Använd funktionen från övning 3 för att undersöka om följande funktioner är linjära:</p>
<ol>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>+</mo><mn>2</mn><mspace width="0.278em"></mspace><mi>t</mi></mrow><annotation encoding="application/x-tex">\pi + 2\;t</annotation></semantics></math></p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><mn>2</mn><mspace width="0.278em"></mspace><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\sin(2\;t)</annotation></semantics></math></p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">x/2</annotation></semantics></math></p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>cos</mo><mo stretchy="false" form="prefix">(</mo><msup><mn>2</mn><mi>t</mi></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\cos(2^t)</annotation></semantics></math></p></li>
</ol>
<h1 id="stegsvar-och-impulsvar">Stegsvar och Impulsvar</h1>
<p>Impulssvar och stegsvar är härligt nog ganska precis vad de låter som. Ett systems impulssvar är den utsignal man får när man skickar in en enhetsimpuls som insignal till systemet och stegsvar är systemets utsignal när man skickar in ett enhetssteg som insignal. Kommer du inte ihåg vad en enhetsimpuls eller ett enhetssteg är för något så titta tillbaka på kapitlet som heter Introduktion. I korthet så är en enhetsimpuls en signal som är definierad som 0 vid alla tidpunkter utom tiden 0 och enhetssteg är en signal definierad som 0 för negativa tidpunkter och 1 för positiva tidpunkter.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd><mn>0</mn><mo>,</mo><mspace width="1.0em"></mspace><mi>n</mi><mo>&lt;</mo><mn>0</mn></mtd></mtr><mtr><mtd><mn>1</mn><mo>,</mo><mspace width="1.0em"></mspace><mi>a</mi><mi>n</mi><mi>n</mi><mi>a</mi><mi>r</mi><mi>s</mi></mtd></mtr></mtable></mrow><mspace width="1.0em"></mspace><mspace width="1.0em"></mspace><mspace width="1.0em"></mspace><mi>u</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd><mn>0</mn><mo>,</mo><mspace width="1.0em"></mspace><mi>t</mi><mo>&lt;</mo><mn>0</mn></mtd></mtr><mtr><mtd><mn>1</mn><mo>,</mo><mspace width="1.0em"></mspace><mi>t</mi><mo>≥</mo><mn>0</mn></mtd></mtr></mtable></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">u[n] = \begin{cases}
    0, \quad n &lt; 0 \\
    1, \quad annars
        \end{cases}
\quad \quad \quad
u(t) =
    \begin{cases}
    0, \quad t &lt; 0 \\
    1, \quad t \geq 0
    \end{cases},</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd><mn>1</mn><mo>,</mo><mspace width="1.0em"></mspace><mi>t</mi><mo>=</mo><mn>0</mn></mtd></mtr><mtr><mtd><mn>0</mn><mo>,</mo><mspace width="1.0em"></mspace><mi>a</mi><mi>n</mi><mi>n</mi><mi>a</mi><mi>r</mi><mi>s</mi></mtd></mtr></mtable></mrow><mspace width="1.0em"></mspace><mspace width="1.0em"></mspace><mspace width="1.0em"></mspace><mi>δ</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd><mn>1</mn><mo>,</mo><mspace width="1.0em"></mspace><mi>t</mi><mo>=</mo><mn>0</mn></mtd></mtr><mtr><mtd><mn>0</mn><mo>,</mo><mspace width="1.0em"></mspace><mi>a</mi><mi>n</mi><mi>n</mi><mi>a</mi><mi>r</mi><mi>s</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\delta[n] =
    \begin{cases}
    1, \quad t = 0 \\
    0, \quad annars
    \end{cases}
\quad \quad \quad
\delta(t) =
    \begin{cases}
    1, \quad t = 0 \\
    0, \quad annars
    \end{cases}</annotation></semantics></math></p>
<p>Impuls- och stegsvar används ofta för att undersöka hur ett system beter sig. Hur systemet svarar på några standardsignaler, som enhetsimpulser och enhetssteg, kan vara till hjälp för att få en grundläggande bild av hur systemet fungerar. Impulssvaret kan även användas för att beräkna det som kallas för systemets överföringsfunktion, men mer om det senare! Impulssvar brukar betecknas med <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">h(t)</annotation></semantics></math> för kontinuerlig tid och <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">h[n]</annotation></semantics></math> för diskret tid. Det här: <span class="math display">$$\textbf{enhetsimpuls} \rightarrow \framebox[1.2\width]{\textbf{LTI-system}} \rightarrow \textbf{impulssvar}$$</span></p>
<p>kan alltså skrivas så här: <span class="math display">$$\delta (t) \rightarrow \framebox[1.2\width]{\textbf{LTI-system}} \rightarrow h(t)$$</span></p>
<p>Kortfattat och fint!</p>
<p>Just för LTI-system så har man särskild nytta av impulssvaret. Det är nämligen så att man kan beräkna ett LTI-systems utsignal genom faltning av insignalen med impulssvaret. <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>*</mo><mi>h</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">y(t)=x(t)*h(t),</annotation></semantics></math> utsignalen kan fås genom faltning av insignalen med impulssvaret Detta för oss genast till frågan: Vad tusan är faltning för något?</p>
<h1 id="faltning">Faltning</h1>
<p>Faltning av en signal f(t) med en signal g(t) skrivs: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>*</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(t)*g(t)</annotation></semantics></math>, dvs det skrivs precis som man ofta skriver multiplikation. Är inte det väldigt dumt undrar ni då? Svaret är ja. Ja, det är jättedumt. Dessvärre så är det så standarden ser ut. Var därför väldigt noga med att inte blanda ihop faltning och multiplikation, det har orsakat många pinsamma misstag genom tiderna.</p>
<p>Ett tips när man beskriver signaler är att skriva multiplikation av signalerna <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>1</mn></msub><annotation encoding="application/x-tex">x_1</annotation></semantics></math> och <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>2</mn></msub><annotation encoding="application/x-tex">x_2</annotation></semantics></math> som <em><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>1</mn></msub><annotation encoding="application/x-tex">x_1</annotation></semantics></math> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>2</mn></msub><annotation encoding="application/x-tex">x_2</annotation></semantics></math></em>, alltså att man skriver ihop dem, och faltningen av <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>1</mn></msub><annotation encoding="application/x-tex">x_1</annotation></semantics></math> och <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>2</mn></msub><annotation encoding="application/x-tex">x_2</annotation></semantics></math> betecknas <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>*</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1 * x_2</annotation></semantics></math>. Men se upp för att det kan blir syntaxkrockar i programmeringssammanhang, då det är standard att använda <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>*</mo><annotation encoding="application/x-tex">*</annotation></semantics></math> för multiplikation där, medans faltning ofta betecknas med <em>conv</em>, från engelskans convolution, eller liknande.</p>
<p>Faltning ses ofta som en operator som är svår att förstå sig på eftersom det kan vara lite besvärligt att få en intuitiv känsla för hur och varför den fungerar. Men vi tar och benar ut den i stora drag i alla fall. Faltning har följande definition i det kontinuerliga fallet:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>*</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi>t</mi></msubsup><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo>−</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><mi>d</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">f(t) * g(t) = \int_{0}^t  f(s) g(t-s) ds</annotation></semantics></math></p>
<p>Lagar om faltning! En tumregel är att den i princip följer samma lagar som multiplikation! <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>*</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mi>b</mi><mi>h</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>a</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>*</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mi>b</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>*</mo><mi>h</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(t) * (a g(t) + b h(t) ) = a(f(t) * g(t)) + b(f(t) * h(t))</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>*</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>*</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(t) * g(t) = g(t) * f(t)</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>*</mo><mo stretchy="false" form="prefix">(</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>*</mo><mi>h</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>*</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>*</mo><mi>h</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(t) * (g(t) * h(t)) = (f(t) * g(t)) * h(t)</annotation></semantics></math> Där a och b är konstanter och f, g och h är funktioner. Det borde även nämnas att följande lagar innefattar även att</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>*</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi>t</mi></msubsup><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo>−</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><mi>d</mi><mi>s</mi><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi>t</mi></msubsup><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo>−</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo stretchy="false" form="postfix">)</mo><mi>d</mi><mi>s</mi><mo>=</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>*</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(t) * g(t) = \int_{0}^t  f(s) g(t-s) ds = \int_{0}^t  f(t-s) g(s) ds = g(t) * f(t)</annotation></semantics></math></p>
<p>Så oroa er inte om integrandens ordning! Det finns även en diskret faltning och även denna följer samma lagar som det kontinuerliga fallet.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo><mo>*</mo><mi>b</mi><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mo>−</mo><mi>∞</mi></mrow><mi>∞</mi></munderover><mi>a</mi><mo stretchy="false" form="prefix">[</mo><mi>k</mi><mo stretchy="false" form="postfix">]</mo><mi>b</mi><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">a[n] * b[n] = \sum_{k=-\infty}^{\infty} a[k] b[n-k]</annotation></semantics></math> Eller om det finns en finit antal värden i talserien. <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo><mo>*</mo><mi>b</mi><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mo>−</mo><mi>N</mi></mrow><mi>N</mi></munderover><mi>a</mi><mo stretchy="false" form="prefix">[</mo><mi>k</mi><mo stretchy="false" form="postfix">]</mo><mi>b</mi><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">a[n] * b[n] = \sum_{k=-N}^{N} a[k] b[n-k]</annotation></semantics></math></p>
<p>Så hur hör allt detta tillsammans med LTI-system? En tolkning av faltning är en kontinuerlig superposition av f (eller g). Men om man inte vill gå in i för djupa detaljer så är faltning i ett nötskal, inom detta området, systemets respons till en insignal. Det vill säga givet insignalen <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math> och system responsen <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">h(t)</annotation></semantics></math>, systemets utsignal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">y(t)</annotation></semantics></math> kan beräknas från <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>*</mo><mi>h</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">y(t) = x(t) * h(t)</annotation></semantics></math> Det vill säga utsignalen fås av en faltning mellan impulssvaret och insignalen. Om du inte vill gå in djupare på teorin så får du helt enkelt acceptera det.<br />
<strong>Övning 4:</strong> Här följer ett kodskelett till en implementering av diskret faltning. Fyll i det som saknas.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">discConvolution ::</span> <span class="dt">DiscTimeFun</span> <span class="co">-- ^ Signal 1</span>
                <span class="ot">-&gt;</span> <span class="dt">DiscTimeFun</span> <span class="co">-- ^ Signal 2</span>
                <span class="ot">-&gt;</span> <span class="dt">DiscTime</span> <span class="co">-- ^ Avstånd från 0,</span>
                <span class="co">-- intervallet sträcker sig från -limit .. limit</span>
                <span class="ot">-&gt;</span> <span class="dt">DiscTimeFun</span> <span class="co">-- ^ Returnfunktion</span>
discConvolution s0 s1 limit <span class="fu">=</span> undefined</code></pre></div>
<p>En kanske enklare metod att beräkna faltningar presenteras i Fourier kapitlet.</p>
<h1 id="sammanfattning">Sammanfattning</h1>
<p>Gratulerar! Du har nu lärt dig</p>
<ul>
<li><p>Vad LTI-system är för något</p></li>
<li><p>Hur man undersöker eller bevisar om ett system är ett LTI-system genom att kontrollera superposition och tidsinvarians</p></li>
<li><p>Hur man implementerar och använder funktioner för superposition och tidsinvarians med funktionell programmering och DSL.</p></li>
<li><p>Vad impulssvar och stegsvar är</p></li>
<li><p>Lite om faltning</p></li>
<li><p>Hur man kan beräkna ett LTI-systems utsignal genom faltning av insignalen med impulssvaret</p></li>
</ul>
<p>Passa nu på att ge dig själv en välförtjänt klapp på axeln innan du går vidare till nästa kapitel!</p>
<h1 id="lösningar">Lösningar</h1>
<p>Övning 1</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isLinearDisc ::</span> <span class="dt">DiscTimeFun</span> <span class="co">-- ^ Insignal 1</span>
            <span class="ot">-&gt;</span> <span class="dt">DiscTimeFun</span> <span class="co">-- ^ Insignal 2</span>
            <span class="ot">-&gt;</span> <span class="dt">DiscSystem</span>  <span class="co">-- ^ System</span>
            <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="co">-- ^ Skalningsfaktor 1</span>
            <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="co">-- ^ Skalningsfaktor 2</span>
            <span class="ot">-&gt;</span> <span class="dt">DiscTime</span> <span class="co">-- ^ Tid då vi mäter</span>
            <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isLinearDisc x0 x1 sys a b t <span class="fu">=</span> testAt (y0&#39; <span class="fu">+</span> y1&#39;) (y0 <span class="ot">`scale`</span> a <span class="fu">+</span> y1 <span class="ot">`scale`</span> b) t
    <span class="kw">where</span> y0  <span class="fu">=</span> discOutSignal sys x0
          y1  <span class="fu">=</span> discOutSignal sys x1
          y0&#39; <span class="fu">=</span> discOutSignal sys (x0 <span class="ot">`scale`</span> a)
          y1&#39; <span class="fu">=</span> discOutSignal sys (x1 <span class="ot">`scale`</span> b)
          testAt a b t <span class="fu">=</span> a t <span class="fu">~=</span> b t</code></pre></div>
<p>Övning 2</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isTimeInvCont ::</span> <span class="dt">ContTimeFun</span> <span class="ot">-&gt;</span> <span class="dt">ContSystem</span> <span class="ot">-&gt;</span> <span class="dt">ContTime</span> <span class="ot">-&gt;</span> <span class="dt">ContTime</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isTimeInvCont x sys t c <span class="fu">=</span> y&#39; t <span class="fu">~=</span> (timeShift y c) t
    <span class="kw">where</span> x&#39; <span class="fu">=</span> timeShift x c
          y  <span class="fu">=</span> contOutSignal sys x
          y&#39; <span class="fu">=</span> contOutSignal sys x&#39;</code></pre></div>
<p><span>haskell</span></p>
<p>Övning 4</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">discConvolution ::</span> <span class="dt">DiscTimeFun</span> <span class="co">-- ^ Signal 1</span>
                <span class="ot">-&gt;</span> <span class="dt">DiscTimeFun</span> <span class="co">-- ^ Signal 2</span>
                <span class="ot">-&gt;</span> <span class="dt">DiscTime</span> <span class="co">-- ^ Interval length -M start</span>
                <span class="ot">-&gt;</span> <span class="dt">DiscTimeFun</span> <span class="co">-- ^ Returnfunktion</span>
discConvolution s0 s1 interval <span class="fu">=</span> sum <span class="fu">$</span> map conv points
    <span class="kw">where</span> points <span class="fu">=</span> [from <span class="fu">..</span> interval]
          from <span class="fu">=</span> negate interval
          conv n m <span class="fu">=</span> (s0 n <span class="fu">*</span> (s1 (n<span class="fu">-</span>m)))</code></pre></div>
